
性能优化
===================================================
主要是经验---车技。

1.如何去优化自己现有的项目，运行更加流畅。
app进程 16M,32M,64M。 8M

2.以后开发项目的时候就要从一开始就摆好发车车技。

-----------------------内存泄漏----------------------------

C/C++ 自己去分配内存和释放内存--手动管理
malloc  free

什么是内存泄露：内存不在GC掌控之内了。
		当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而就导致
		对象不能被回收。这种导致了本该被回收的对象不能被回收而停留在堆内存中，就产生了内存泄漏

了解java的GC内存回收机制：某对象不再有任何的引用的时候才会进行回收。

ArrayList<String> list = new Arraylist<String>();


了解内存分配的几种策略：
1.静态的
	静态的存储区：内存在程序编译的时候就已经分配好，这块的内存在程序整个运行期间都一直存在。
	它主要存放静态数据、全局的static数据和一些常量。

2.栈式的
	在执行函数(方法)时，函数一些内部变量的存储都可以放在栈上面创建，函数执行结束的时候这些存储单元就会自动被释放掉。
	栈内存包括分配的运算速度很快，因为内置在处理器的里面的。当然容量有限。
3.堆式的
	也叫做动态内存分配。有时候可以用malloc或者new来申请分配一个内存。在C/C++可能需要自己负责释放（java里面直接依赖GC机制）。
	在C/C++这里是可以自己掌控内存的，需要有很高的素养来解决内存的问题。java在这一块貌似程序员没有很好的方法自己去解决垃圾内存，需要的是编程的时候就要注意自己良好的编程习惯。

区别：堆是不连续的内存区域，堆空间比较灵活也特别大。
	栈式一块连续的内存区域，大小是有操作系统觉决定的。

堆管理很麻烦，频繁地new/remove会造成大量的内存碎片，这样就会慢慢导致效率低下。
对于栈的话，他先进后出，进出完全不会产生碎片，运行效率高且稳定。

public class Main{
	int a = 1;
	Student s = new Student();
	public void XXX(){
		int b = 1;//栈里面
		Student s2 = new Student();
	}

}

1.成员变量全部存储在堆中(包括基本数据类型，引用及引用的对象实体)---因为他们属于类，类对象最终还是要被new出来的。
2.局部变量的基本数据类型和引用存储于栈当中，引用的对象实体存储在堆中。-----因为他们属于方法当中的变量，生命周期会随着方法一起结束。

我们所讨论内存泄露，主要讨论堆内存，他存放的就是引用指向的对象实体。

有时候确实会有一种情况：当需要的时候可以访问，当不需要的时候可以被回收也可以被暂时保存以备重复使用。

比如：ListView或者GridView、REcyclerView加载大量数据或者图片的时候，
	图片非常占用内存，一定要管理好内存，不然很容易内存溢出。
	滑出去的图片就回收，节省内存。看ListView的源码----回收对象，还会重用ConvertView。
	如果用户反复滑动或者下面还有同样的图片，就会造成多次重复IO（很耗时），
	那么需要缓存---平衡好内存大小和IO，算法和一些特殊的java类。
	算法：lrucache(最近最少使用先回收)
	特殊的java类：利于回收，StrongReference，SoftReference，WeakReference，PhatomReference

StrongReference强引用：
	回收时机：从不回收 使用：对象的一般保存  生命周期：JVM停止的时候才会终止
SoftReference，软引用
	回收时机：当内存不足的时候；使用：SoftReference<String>结合ReferenceQueue构造有效期短；生命周期：内存不足时终止
WeakReference，弱引用
	回收时机：在垃圾回收的时候；使用：同软引用； 生命周期：GC后终止
PhatomReference 虚引用
	回收时机：在垃圾回收的时候；使用：合ReferenceQueue来跟踪对象呗垃圾回收期回收的活动； 生命周期:GC后终止

开发时，为了防止内存溢出，处理一些比较占用内存大并且生命周期长的对象的时候，可以尽量使用软引用和弱引用。
软引用比LRU算法更加任性，回收量是比较大的，你无法控制回收哪些对象。

比如使用场景：默认头像、默认图标。
ListView或者GridView、REcyclerView要使用内存缓存+外部缓存(SD卡)



---------------内存泄露例子----------------
单例模式导致内存对象无法释放而导致内存泄露

MainActivity在内存当中泄露了。
这个故事告诉我们能用Application的context就用Application的
CommonUtil生命周期跟MainActivity不一致，而是跟Application进程同生同死。

旋转3次：会在内存里面开辟三个MainActivity
实际上3次以上都只会有2个MainActivity。当GC回收的时候会将除了第0个和最后这一个留着其他的都会被回收。

优化两个情况：
	1.主动；平时
	2.被动，很卡的时候  出现问题的时候。

如果我们不知道代码内存泄露的情况，如何判断我们的项目里面有哪些是有内存泄露情况的？

1.凭借工具结合自己的经验来判断。
往往我们的app在某个时候或者某个 操作以后会出现很卡的现象。

1）判断就是查看内存抖动情况

Android Monitor
MAT (对Eclipse插件使用的，也有独立分析工具)

查找引用了该对象的外部对象有哪些，
然后一个一个去猜，查找可能内存泄露的嫌疑犯，依据：看(读代码和猜)他们的生命周期是否一致(可以通过快照对比)，如果生命周期一致了肯定不是元凶。

排除一些容易被回收的(软引用、虚引用、弱引用)


设置监听很容易出现内存泄露
handler.post(callback)
onDestroy(){
	handler.removeCallback();
}

===================第三节课========================

往往做项目的时候情况非常复杂，或者项目做得差不多了想起来要性能优化检查下内存泄露。

如何找到项目中存在的内存泄露的这些地方呢？

1.确定是否存在内存泄露
	1)Android Monitors的内存分析
		最直观的看内存增长情况，知道该动作是否发生内存泄露。
		动作发生之前：GC完后内存1.4M; 动作发生之后：GC完后内存1.6M

	2)使用MAT内存分析工具
	MAT分析heap的总内存占用大小来初步判断是否存在泄露
	Heap视图中有一个Type叫做data object，即数据对象，也就是我们的程序中大量存在的类类型的对象。
	在data object一行中有一列是“Total Size”，其值就是当前进程中所有Java数据对象的内存总量，
	一般情况下，这个值的大小决定了是否会有内存泄漏。
	我们反复执行某一个操作并同时执行GC排除可以回收掉的内存，注意观察data object的Total Size值，
	正常情况下Total Size值都会稳定在一个有限的范围内，也就是说由于程序中的的代码良好，没有造成对象不被垃圾回收的情况。
	反之如果代码中存在没有释放对象引用的情况，随着操作次数的增多Total Size的值会越来越大。
那么这里就已经初步判断这个操作导致了内存泄露的情况。

2.先找怀疑对象(哪些对象属于泄露的)
	MAT对比操作前后的hprof来定位内存泄露是泄露了什么数据对象。（这样做可以排除一些对象，不用后面去查看所有被引用的对象是否是嫌疑）
	快速定位到操作前后所持有的对象哪些是增加了(GC后还是比之前多出来的对象就可能是泄露对象嫌疑犯)
	技巧：Histogram中还可以对对象进行Group，比如选择Group By Package更方便查看自己Package中的对象信息。

3. MAT分析hprof来定位内存泄露的原因所在。(哪个对象持有了上面怀疑出来的发生泄露的对象)
	1）Dump出内存泄露“当时”的内存镜像hprof，分析怀疑泄露的类；
	2）把上面2得出的这些嫌疑犯一个一个排查个遍。步骤：
		(1)进入Histogram，过滤出某一个嫌疑对象类
		(2)然后分析持有此类对象引用的外部对象（在该类上面点击右键List Objects--->with incoming references）
		(3)再过滤掉一些弱引用、软引用、虚引用，因为它们迟早可以被GC干掉不属于内存泄露
		   (在类上面点击右键Merge Shortest Paths to GC Roots--->exclude all phantom/weak/soft etc.references)
		(4)逐个分析每个对象的GC路径是否正常
		   此时就要进入代码分析此时这个对象的引用持有是否合理，这就要考经验和体力了！
		   （比如上课的例子中：旋转屏幕后MainActivity有两个，肯定MainActivity发生泄露了，
		     那谁导致他泄露的呢？原来是我们的CommonUtils类持有了旋转之前的那个MainActivity他，
		     那是否合理？结合逻辑判断当然不合理，由此找到内存泄露根源是CommonUtils类持有了该MainActivity实例造成的。
		     怎么解决？罪魁祸首找到了，怎么解决应该不难了，不同情况解决办法不一样，要靠你的智慧了。）

context.getapplictioncontext()可以吗？
可以！！只要让CommonUtils类不直接只有MainActivity的实例就可以了。

一般我是最笨的方法解决
new出来对象，用完后把它 = null;这样算不算优化
假如：方法里面定义的对象，要去管吗？一般不需要管。
	自己=null，要自己去控制所有对象的生命周期 判断各种空指针，有点麻烦。
	但是在很多时候去想到主动将对象置为null是很好的习惯。


------------------
判断一个应用里面内存泄露避免得很好，怎么看？
当app退出的时候，这个进程里面所有的对象应该就都被回收了，尤其是很容易被泄露的（View，Activity）是否还内存当中。
可以让app退出以后，查看系统该进程里面的所有的View、Activity对象是否为0.
工具：使用AndroidStudio--AndroidMonitor--System Information--Memory Usage查看Objects里面的views和Activity的数量是否为0.
命令行模式：       ？？？？


===========================内存泄露经常出现的例子=============================
内存泄露(Memory Leak)：
	进程中某些对象已经没有使用价值了，但是他们却还可以直接或者间接地被引用到GC Root导致无法回收。
	当内存泄露过多的时候，再加上应用本身占用的内存，日积月累最终就会导致内存溢出OOM.
内存溢出（OOM）：


1.静态变量引起的内存泄露
	当调用getInstance时，如果传入的context是Activity的context。只要这个单利没有被释放，那么这个
	Activity也不会被释放一直到进程退出才会释放。
	public class CommUtil {
	    private static CommUtil instance;
	    private Context context;
	    private CommUtil(Context context){
		this.context = context;
	    }

	    public static CommUtil getInstance(Context mcontext){
		if(instance == null){
		    instance = new CommUtil(mcontext);
		}
	//        else{
	//            instance.setContext(mcontext);
	//        }
		return instance;
	    }

2.非静态内部类引起内存泄露
(包括匿名内部类)
	错误的示范：

	    public void loadData(){//隐士持有MainActivity实例。MainActivity.this.a
		new Thread(new Runnable() {
		    @Override
		    public void run() {
			while(true){
			    try {
				//int b=a;
				Thread.sleep(1000);
			    } catch (InterruptedException e) {
				e.printStackTrace();
			    }
			}
		    }
		}).start();
	    }
	解决方案：
	将非静态内部类修改为静态内部类。
	（静态内部类不会隐士持有外部类）

当使用软引用或者弱引用的时候，MainActivity难道很容易或者可以被GC回收吗？》
GC回收的机制是什么？当MainActivity不被任何的对象引用。
虽然Handler里面用的是软引用/弱引用，但是并不意味着不存在其他的对象引用该MainActivity。
我连MainActivity都被回收了，那他里面的Handler还玩个屁。

3.不需要用的监听未移除会发生内存泄露
	例子1：
//        tv.setOnClickListener();//监听执行完回收对象
        //add监听，放到集合里面
        tv.getViewTreeObserver().addOnWindowFocusChangeListener(new ViewTreeObserver.OnWindowFocusChangeListener() {
            @Override
            public void onWindowFocusChanged(boolean b) {
                //监听view的加载，view加载出来的时候，计算他的宽高等。

                //计算完后，一定要移除这个监听
                tv.getViewTreeObserver().removeOnWindowFocusChangeListener(this);
            }
        });

	例子2：
	        SensorManager sensorManager = getSystemService(SENSOR_SERVICE);
        Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);
        sensorManager.registerListener(this,sensor,SensorManager.SENSOR_DELAY_FASTEST);
        //不需要用的时候记得移除监听
        sensorManager.unregisterListener(listener);


4.资源未关闭引起的内存泄露情况
	比如：BroadCastReceiver、Cursor、Bitmap、IO流、自定义属性attribute
attr.recycle()回收。
当不需要使用的时候，要记得及时释放资源。否则就会内存泄露。

5.无限循环动画
没有在onDestroy中停止动画，否则Activity就会变成泄露对象。
比如：轮播图效果。


====================================性能优化的帮助工具=================
	MAT,
	Memory Monitor(属于AndroidMonitor中一个模块)，
	HeapTool(查看堆信息)，
	Allaction Tracking，
	LeakCanary
	Lint工具

1.Allaction Tracking
追踪内存分配信息。可以很直观地看到某个操作的内存是如何进行一步一步地分配的。


2.LeakCanary
Square公司
可以直接在手机端查看内存泄露的工具
实现原理：本质上还是用命令控制生成hprof文件分析检查内存泄露。
然后发送通知。
Application
	install()
LeakCanary
	androidWatcher()
RefWatcher
	new AndroidWatcherExecutor() --->dumpHeap()/analyze()(--->runAnalysis())--->Hprof文件分析
	new AndroidHeapDumper()
	new ServiceHeapDumpListener


3.Lint分析工具
Android Studio很方便 很好用。
	检测资源文件是否有没有用到的资源。
	检测常见内存泄露
	安全问题SDK版本安全问题
	是否有费的代码没有用到
	代码的规范---甚至驼峰命名法也会检测
	自动生成的罗列出来
	没用的导包
	可能的bug


渲染机制以及优化

一、了解渲染刷新机制
VSYNC(垂直刷新/绘制)

60HZ是屏幕刷新理想的频率。60fps---一秒内绘制的帧数。
24帧/秒 电源胶卷时代

在60fps内，系统会得到发送的VSYNC(垂直刷新)信号qu去进行渲染，就会正常地绘制。
60fps要求：每一帧只能停留16ms.

VSYNC：有两个概念
	1）Refresh Rate：屏幕在一秒时间内刷新屏幕的次数----有硬件的参数决定，比如60HZ.
	2）Frame Rate：GPU在一秒内绘制操作的帧数，比如：60fps。

GPU刷新：GPU帮助我们将UI组件等计算成纹理Texture和三维图形Polygons
	同时会使用OpenGL---会将纹理和Polygons缓存在GPU内存里面。
View Tree。

卡顿是如何造成的
卡主线程了！（卡UI线程）
1.外部引起的
	比如：Activity里面直接进行网络访问/大文件的IO操作
内存这一块有些什么要注意的。

	1）内存抖动的问题。
		new Object

		obj = null
	2)一个方法太耗时了。

2.View本身的卡顿
自定义View要注意的，能否优化、

	1）可以使用Allocation Tracing来定位大致的情况
	2）可以使用TraceView来确定详细的问题所在。

优化：
1.渲染性能的优化
2.防止过度绘制


---------------------------
在我们的绘制渲染机制里面比较耗时的：
1.CPU计算时间
	CPU的优化，从减轻加工View对象成Polygons和Texture来下手
	View Hierarchy中包涵了太多的没有用的view，这些view根本就不会显示在屏幕上面，
	一旦触发测量和布局操作，就会拖累应用的性能表现。

	1.如何找出里面没用的view呢？或者减少不必要的view嵌套。
	工具：Hierarchy Viewer检测

	优化：
		1）当我们的布局是用的FrameLayout的时候，我们可以把它改成merge
			可以避免自己的帧布局和系统的ContentFrameLayout帧布局重叠造成重复计算(measure和layout)
	ViewStub：当加载的时候才会占用。不加载的时候就是隐藏的，仅仅占用位置。

	[hierarchyviewer]Unable to capture data for node
	android.widget.LinearLayout@e6fdb11 in window com.example.android.mobileperf.render/com.example.android.mobileperf.render.ChatumLatinumActivity on device 192.168.56.101:5555

	三个圆点分别代表：测量、布局、绘制三个阶段的性能表现。
	1）绿色：渲染的管道阶段，这个视图的渲染速度快于至少一半的其他的视图。
	2）黄色：渲染速度比较慢的50%。
	3）红色：渲染速度非常慢。

	优化思想:查看自己的布局，层次是否很深以及渲染比较耗时，然后想办法能否减少层级以及优化每一个View的渲染时间。


2.CPU将计算好的Polygons和Texture传递到GPU的时候也需要时间
	OpenGL ES API允许数据上传到GPU后可以对数据进行保存，做了缓存。

3.GPU进行格栅化
	优化：尽量避免过度绘制（overdraw）
	GPU如何优化：
		1.背景经常容易造成过度绘制。
		手机开发者选项里面找到工具：Debug GPU overdraw
		由于我们布局设置了背景，同时用到的MaterialDesign的主题会默认给一个背景。
		/解决的办法：将主题添加的背景去掉

		2.自定义控件如何处理过度绘制。
		可以通过裁剪来处理。

===================================电量优化====================


使用时出现的错误：
1.json: unsupported value: NaN
	有人用了描述：
	the problem started when reset the battery stats and enabled full-wake-history
	解决：重启手机再试就好了。

2.打开生成的HTML显示错误如下：
WARNING: Visualizer disabled. If you see this message, download the HTML then open it.
解决：需要翻墙访问谷歌服务。

3.进部署好的动脑服务器docker，显示错误如下：
{"UploadResponse":[{"sdkVersion":23,"historianV2Cs...

https://github.com/google/battery-historian/issues/64
解决：You need a network connection.需要翻墙。 动脑的centos无法翻墙访问谷歌服务导致。

4.进部署好的动脑服务器docker，没有显示错误，但是最上面提示了红色的颜色块，表示访问出错。
解决：无法翻墙访问谷歌服务导致。

=============================================================

重要的参数：WiFi、wake_lock、conn、mobile_ratio(蜂窝信号)

1.为了省电，有些工作可以放当手机插上电源的时候去做。往往这样的情况非常多。
像这些不需要及时地和用户交互的操作可以放到后面处理。
比如：360手机助手，当充上电的时候，才会自动清理手机垃圾，自动备份上传图片、联系人等到云端。

提问：拍照和图片的处理，他们可以做一些电量的优化吗？
假如现在没有充电，电量比较低，拍照动作是需要立马执行的，
但是图片处理（需要消耗大量的计算---电量的大量消耗）是否可以放在用户手机插上电源之后来处理？

如何立即获取手机当前充电状态，我们可以有针对性地对一些代码做优化。

2.wake_lock
系统为了节省电量，CPU在没有任务忙的时候就会自动进入休眠。
有任务需要唤醒CPU高效执行的时候，就会给CPU加wake_lock锁。

wake_lock锁主要是相对系统的休眠而言的，意思就是我的程序给CPU加了这个锁那系统就不会休眠了，这样做的目的是为了全力配合我们程序的运行。有的情况如果不这么做就会出现一些问题，比如微信等及时通讯的心跳包会在熄屏不久后停止网络访问等问题。所以微信里面是有大量使用到了wake_lock锁。

wake_lock:两种锁，一种计数锁；非计数锁(锁了很多次，只需要release一次就可以解除了)
源码：count++

wake_lock应该是大家开发时经常用的手段吧，所以没有特别细地讲解，如果大家需要的话下节课给大家补充下这块的概念和使用。

大家经常犯的错误，我们很容易去唤醒CPU来干货，但是很容易忘记释放wake_lock.
解决：powerManager的API
记得添加权限：
<uses-permission android:name="android.permission.INTERNET"></uses-permission>
    <uses-permission android:name="android.permission.WAKE_LOCK"></uses-permission>
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"></uses-permission>

  mWakelock.acquire();//唤醒CPU
  mWakelock.release();//记得释放CPU锁

//判断网络连接
   private boolean isNetWorkConnected() {
        ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();
        return (activeNetworkInfo!=null&&activeNetworkInfo.isConnected());
    }


//---------------
如何去改进，对任务调度的优化。
//--------------
网络优化---也解决电量问题。


    public void setRepeating(int type, long triggerAtMillis,
            long intervalMillis, PendingIntent operation) {
        setImpl(type, triggerAtMillis, legacyExactLength(), intervalMillis, 0, operation,
                null, null, null, null, null);
    }

    public void setExact(int type, long triggerAtMillis, PendingIntent operation) {
        setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, 0, operation, null, null, null,
                null, null);
    }

原因：
WINDOW_HEURISTIC:探试的，探索的;（意思：有范围浮动的，时间不确定的）
    private long legacyExactLength() {
        return (mAlwaysExact ? WINDOW_EXACT : WINDOW_HEURISTIC);
    }


锁屏和点亮屏幕的广播。监听。

如果电量采集不到，可能要进入手机的工程模式，打开电量日志采集。


python historian.py -a dongnaobugreport.txt > dongnaobugreport.txt.html


优化四：大量高频次的CPU唤醒及操作，我们最好把这些操作集中处理。
我们可以采取一些算法来解决。
可以借鉴谷歌的精髓，JobScheduler/GCM


python historian.py -a batterystat666s.txt > battery.html

电量优化---网络优化



5.0API以后用的JobScheduler
5.0API之前用GCM---谷歌的Google Play ServiceManager，国内基本是废的。(里面有很多的网络优化的代码--包括访问策略等)


JobInfo
JobScheduler
JobService


进程1
MyService{
	MyBinder extends MyInterface.Stub{
		a(){
		//
		}
	}
}

MyInterface.aidl{
	接口方法a();
}

进程2
MyInterface.aidl{
	接口方法a();
}

bindService(service,new ServiceConnection(){
	onServiceConnected(IBinder binder){
		//建立连接
		MyInterface interface = binder.asInterface();

	}
})

interface.a();


Zygote进程--Linux核心
启动系统进程SystemServer，开启一些列的关键服务：AMS/PMS/WMS/JobSchedulerService


/data/system/job/jobs.xml文件---永久的任务。


网络的优化

1.请求的缓存。
Http请求是可以做缓存的。


三级缓存
内存缓存、外部缓存
算法LruCache
+自定的 一周过期等等。
Sqlite缓存+加密

=============================================
Bitmap的优化

图片压缩

BitmapFactory

BitmapFactory.Options:参数：
inDensity:bitmap的像素密度
inTargetDensity：bitmap最终的像素密度

DensityDpi(屏幕的像素密度)  分辨率		Density
160dpi				320x533		1

px  = dp*Density

 图片存在的几种形式：
	File
	流的形式
	Bitmap的形式---内存


1.质量压缩
AB
CD
压缩后
AA
AA


2.尺寸压缩

3.采样率压缩



=====================终极压缩====================================

1.IOS拍照1M的图片要比安卓拍照排出来的5M的图片还要清晰。
都是在同一个环境下，保存的都是JPEG。

为什么？

2.图像处理引擎
95年 JPEG处理引擎，用于最初的在PC上面处理图片的引擎。

05年  skia开源的引擎, 开发了一套基于JPEG处理引擎的第二次开发。便于浏览器的使用。

07年， 安卓上面用的什么引擎？
skia引擎，阉割版。
--------------------
谷歌拿了skia 思考了半天做了一个决定，去掉一个编码算法---哈夫曼算法。采用定长编码算法。
但是解码还是保留了哈夫曼算法。
-----------------------
导致了图片处理后文件变大了。
理由：当时由于CPU和内存在手机上都非常吃紧 性能差，由于哈夫曼算法非常吃CPU，被迫用了其他的算法。
 ---------------------------------------------------------
|   我们的优化：                                            |
|  绕过安卓Bitmap API层，来自己编码实现----修复使用哈夫曼算法。   |
 ----------------------------------------------------------

argb
一个像素点包涵四个信息：alpha，red,green，blue

a b c d e

abcde acdbe bacde ⋯⋯

101010100011100
a:001
b:010
c:011
d:100
e:101
用3位来表示一个字符信息，属于定长编码的最优。

abcde
001 010 011 100 101
加权信息编码

a:80%
b:10%
c:10%
d:0%
e:0%
这种情况，编码就可以优化了
a:01
b:10
c:11
优化后的abc:01 10 11
优化前的abc:001 010 011

问题来了：
	如何得到每一个字母出现的权重？
哈夫曼编码：需要去扫描真个信息(图片信息--每一个像素包括ARGB)，药大量计算，很吃CPU。

1280*800像素*4

-------------------如何实现----------=-----------

下载JPEG引擎使用的库---libjpeg库
http://www.ijg.org/

基于该引擎来做一定的开发----自己实现编码。

1.导入库文件libjpegbither.so
2.导入头文件
3.写mk文件
Android.mk
Applicatoin.mk

4.写代码
C++: XX.cpp
C:   XX.c


1.将android的bitmap解码，并转换成RGB数据
一个图片信息---像素点(argb)
alpha去掉


2.JPEG对象分配空间以及初始化
3.指定压缩数据源
4.获取文件信息
5.为压缩设置参数，比如图像大小、类型、颜色空间
  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
6.开始压缩
jpeg_start_compress()
7.压缩结束
jpeg_finish_compress()
8.释放资源

===============================数据传输效率优化====================

一、数据的序列化和反序列化
服务器对象Object----流--->客户端Object对象

序列化：
Serializable/Parcelable

时间：1ms * 10 * 50 * 20 = 10000ms
性能：内存的浪费和CPU计算时间的占用。

json/xml
json序列化的工具GSON/fastjson

FlatBuffer:基于二进制的文件。
json：基于字符串的

Gson.from("")
Gson.toString(object)

PeopleList{
	List<People> peoples;

}

============================多线程===========================
生产者消费者线程模式

25fps
60fps

MessageQueue 库存

AsyncTask 异步任务

Callable
Future

异步任务执行的结果，主线程无法轻易的获取

Java FutureTask 异步任务操作提供了便利性
1.获取异步任务的返回值
2.监听异步任务的执行完毕
3.取消异步任务

doBackground(call)
call的返回值在Future的done方法中获取

->onPostExecute

new MyTask().execute();

实例化：
new AsyncTask() -> new FutureTask()

执行：
Executor.execute(mFuture) -> SerialExecutor.myTasks（队列）
-> (线程池)THREAD_POOL_EXECUTOR.execute

线程池中的所有线程，为了执行异步任务

CORE_POOL_SIZE 核心线程数
MAXIMUM_POOL_SIZE 最大线程数量
KEEP_ALIVE 1s闲置回收
TimeUnit.SECONDS 时间单位
sPoolWorkQueue 异步任务队列
sThreadFactory 线程工厂

如果当前线程池中的数量小于corePoolSize，创建并添加的任务。
如果当前线程池中的数量等于corePoolSize，缓冲队列 workQueue未满，那么任务被放入缓冲队列、等待任务调度执行。
如果当前线程池中的数量大于corePoolSize，缓冲队列workQueue已满，并且线程池中的数量小于maximumPoolSize，新提交任务会创建新线程执行任务。
如果当前线程池中的数量大于corePoolSize，缓冲队列workQueue已满，并且线程池中的数量等于maximumPoolSize，新提交任务由Handler处理。
当线程池中的线程大于corePoolSize时，多余线程空闲时间超过keepAliveTime时，会关闭这部分线程。

public static final Executor THREAD_POOL_EXECUTOR
= new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,
		TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);

1.线程池容量不够抛出异常
2.内存泄露
3.一个线程，一个异步任务（？）

=================安装包的性能优化=================
一个字：删！！删不了就尽量小。

1.图片压缩
图片：apk里面的资源图片 压缩图片
svg图片：一些图片的描述，牺牲CPU的计算能力的，节省空间。
使用的原则：简单的图标。

webp:谷歌现在非常提倡的使用。保存图片比较小。
	VP8派生而来的。webp的无损压缩比PNG文件小45%左右，即使PNG进过其他的压缩工具压缩后，
	任然可以减小到PNG的28%。

	Facebook在用、腾讯、淘宝。
	缺点：加载相比于PNG要慢很多。 但是配置比较高。
	工具：http://isparta.github.io/

2.资源动态加载：
	比如：emoji表情、换肤
	动态下载的资源。
	一些模块的插件化动态添加。

3.Lint工具 建议优化的点
	1）检测没有用的布局 删除
	2）未使用到的资源 比如 图片 ---删除
	3）建议String.xml有一些没有用到的字符。

4.极限压缩
7zZip工具的使用。

5.Proguard 混淆。
让apk变小。为什么？
	1）可以删除注释和不用的代码。
	2）将java文件名改成短名a.java，b.java
	3）方法名等 CommonUtil.getDisplayMetrix();--》a.a()




=================在常规的安装包的优化之外继续压缩---资源文件再压缩=======================

系统编译完成apk文件以后：
映射关系：res/drawable/ic_launcher.png ----- > 0x7f020000

再做“混淆”：要实现将res/drawable/ic_launcher.png图片改成a.png
drawable文件的名字
String文件的名字
layout的名字
比如：R.string.description--->R.string.a
	res/drawable/ic_launcher.png图片改成a.png

还可以更加夸张
res/drawable--->r/d
res/value-->r/v
res/drawable/ic_launcher.png图片改成r/d/a.png


读取resources.arsc二进制文件，然后修改某一段一段的字节。
有一段叫做：res/drawable/ic_launcher.png  在自己数组当中的第800位-810位
将这一段第800位-810位替换成改成r/d/a.png 的字节码。

args参数：
Lsn10SearchView.apk -config config.xml -7zip 7za.exe -out xxx/hehe -mapping xxx/yyy.txt

1.12M
1.03M
920K


什么是Zipalign？什么是Zipaligned？
http://bbs.ihei5.com/thread-171596-1-1.html

------------------main函数运行配置-------------------
在项目上右键-->Run as--->RunConfiguration
选择Arguments
在Program arguments里面填写如下：

input.apk -config config.xml -out outapkdir/haha -7zip 7za.exe

或者
input.apk -config config.xml -7zip 7za.exe

----------------------------------
图片压缩

 通过色彩深度，透明通道的压缩，不明显降低图片质量情况下减小图片大小。色彩深度计算机图形学领域表示在位图或者视频帧缓冲区中储存1像素的颜色所用的位数，它也称为位/像素（bpp）。色彩深度越高，可用的颜色就越多。
PNG图片优化压缩的文章：
  http://www.wufangbo.com/png-image-optimization/


================================activity 的启动流程=====================


ActivityManagerService（ActivityManagerNative）



ActivityStackSupervisor   管理整个手机任务栈



ActivityStack   Activity的栈（任务栈）


PackageManagerService(完成组件在清单里的扫描和注册)


ActivityThread(安卓java应用层的入口函数类)


C/S 架构思想

ServiceManager

多进程多任务多窗口多app


分模块思想

Activity


分层次思想

热修复
1.阿里系：DeXposed。andfix
	从底层C的二进制来入手的。

2.腾讯系：tinker
	Java类加载机制来入手的。


什么是热修复？
	一般的bug修复，都是等下一个版本解决，然后发布新的apk。
	热修复：可以直接在客户已经安装的程序当中修复bug。

bug一般会出现在某个类的某个方法地方。
如果我们能够动态地将客户手机里面的apk里面的某个类给替换成我们已经修复好的类。

Instant run
在做今天的热修复的时候记得把Instant run功能关闭。不然会影响我们今天的热修复实现。
dex分包。mutildex

如何实现呢？实现的原理？
从Java的类加载机制来入手的。
classLoader

安卓是如何加载classes.dex文件，启动程序。

public class PathClassLoader extends BaseDexClassLoader {
用来加载应用程序的dex

public class DexClassLoader extends BaseDexClassLoader {
可以加载指定的某个dex文件。（限制：必须要在应用程序的目录下面）

修复方案：搞多个dex。
第一个版本：classes.dex
修复后的补丁包：classes2.dex（包涵了我们修复xxx.class）

这种实现方式也可以用于插件开发。

2.如果可以解决这个问题：把两个dex合并---将修复的class替换原来出bug的class.

通过BaseDexClassLoader调用findClass(className)
Class<?> findClass(String name)

将修复好的dex插入到dexElements的集合，位置：出现bug的xxx.class所在的dex的前面。

List of dex/resource (class path) elements.
Element[] dexElements;存储的是dex的集合

最本质的实现原理：类加载器去加载某个类的时候，是去dexElements里面从头往下查找的。
fixed.dex,classes1.dex,classes2.dex,classes3.dex


=================AS打包multidex(官方待验证)============================
1.
dependencies {
    compile 'com.android.support:multidex:1.0.1'
}

2.
defaultConfig {
        multiDexEnabled true
    }

3.
buildTypes {
release {
    multiDexKeepFile file('dex.keep')
    def myFile = file('dex.keep')
    println("isFileExists:"+myFile.exists())
    println "dex keep"
    minifyEnabled true
    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
}
}

4.
public class MyApplication extends Application{

	@Override
	protected void attachBaseContext(Context base) {
		// TODO Auto-generated method stub
		MultiDex.install(base);
	}

}

BaseDexClassLoader类{
	DexPathList pathList；


}
DexPathList类{
	Element[] dexElements;
}
源码链接：
http://androidxref.com/4.4.2_r1/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java#pathList
http://androidxref.com/4.4.2_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java
提供参考源码解析文章阅读：
http://blog.csdn.net/ch15851302205/article/details/44671687

Element[] dexElements;原来的
Element[] dexElements2;合并以后的

1.找到MyTestClass.class
	dn_fix_ricky_as\app\build\intermediates\bin\MyTestClass.class
2.配置dx.bat的环境变量
	Android\sdk\build-tools\23.0.3\dx.bat
3.命令
dx --dex --output=D:\Users\ricky\Desktop\dex\classes2.dex D:\Users\ricky\Desktop\dex
命令解释：
	--output=D:\Users\ricky\Desktop\dex\classes2.dex   指定输出路径
	D:\Users\ricky\Desktop\dex    最后指定去打包哪个目录下面的class字节文件(注意要包括全路径的文件夹，也可以有多个class)


===========================Service=========================
-----------------------------------------------
service：是一个后台服务，专门用来处理常驻后台的工作的组件。

即时通讯：service来做常驻后台的心跳传输。
1.良民：核心服务尽可能地轻！！！
很多人喜欢把所有的后台操作都集中在一个service里面。
为核心服务专门做一个进程，跟其他的所有后台操作隔离。
树大招风，核心服务千万要轻。

一、优先级

进程的重要性优先级：（越往后的就越容易被系统杀死）
1.前台进程；Foreground process
	1）用户正在交互的Activity（onResume（））
	2）当某个Service绑定正在交互的Activity。
	3）被主动调用为前台Service（startForeground()）
	4）组件正在执行生命周期的回调（onCreate()/onStart()/onDestroy()）
	5）BroadcastReceiver 正在执行onReceive();

2.可见进程；Visible process
	1)我们的Activity处在onPause()（没有进入onStop()）
	2)绑定到前台Activity的Service。

3.服务进程；Service process
	简单的startService()启动。
4.后台进程；Background process
	对用户没有直接影响的进程----Activity出于onStop()的时候。
	android:process=":xxx"
5.空进程； Empty process
	不含有任何的活动的组件。（android设计的，为了第二次启动更快，采取的一个权衡）


二、如何提升进程的优先级（尽量做到不轻易被系统杀死）

1.QQ采取在锁屏的时候启动一个1个像素的Activity，当用户解锁以后将这个Activity结束掉（顺便同时把自己的核心服务再开启一次）。被用户发现了就不好了。
故事：小米撕逼。
背景：当手机锁屏的时候什么都干死了，为了省电。
锁屏界面在上面盖住了。
监听锁屏广播，锁了---启动这个Activity。
监听锁屏的，  开启---结束掉这个Activity。
要监听锁屏的广播---动态注册。
ScreenListener.begin(new xxxListener
	onScreenOff()
);


被系统无法杀死的进程。

2.app运营商和手机厂商可能有合作关系---白名单。

3.双进程守护---可以防止单个进程杀死，同时可以防止第三方的360清理掉。
	一个进程被杀死，另外一个进程又被他启动。相互监听启动。

	A<--->B
	杀进程是一个一个杀的。本质是和杀进程时间赛跑。


4.JobScheduler
把任务加到系统调度队列中，当到达任务窗口期的时候就会执行，我们可以在这个任务里面启动我们的进程。
这样可以做到将近杀不死的进程。

5.监听QQ,微信，系统应用，友盟，小米推送等等的广播，然后把自己启动了。

6.利用账号同步机制唤醒我们的进程

AccountManager

7.NDK来解决，Native进程来实现双进程守护。



总结：要根据自己的需要来使用。




======================提升应用的启动速度 和 splash页面的设计==========================
1.启动分为两种方式：
	1）冷启动：当直接从桌面上直接启动，同时后台没有该进程的缓存，这个时候系统就需要
	重新创建一个新的进程并且分配各种资源。
	2）热启动：该app后台有该进程的缓存，这时候启动的进程就属于热启动。

	热启动不需要重新分配进程，也不会Application了，直接走的就是app的入口Activity，这样就速度快很多

2.如何测量一个应用的启动时间
	使用命令行来启动app，同时进行时间测量。单位：毫秒
	adb shell am start -W [PackageName]/[PackageName.MainActivity]
	adb shell am start -W com.love.jax.optimize/com.love.jax.optimize.MainActivity


	ThisTime: 165 指当前指定的MainActivity的启动时间
	TotalTime: 165 整个应用的启动时间，Application+Activity的使用的时间。
	WaitTime: 175 包括系统的影响时间---比较上面大。

3.应用启动的流程
	Application从构造方法开始--->attachBaseContext()--->onCreate()
	Activity构造方法--->onCreate()--->设置显示界面布局，设置主题、背景等等属性
	--->onStart()--->onResume()--->显示里面的view（测量、布局、绘制，显示到界面上）

	时间花在哪里了？

4.减少应用的启动时间的耗时
	1）、不要在Application的构造方法、attachBaseContext()、onCreate()里面进行初始化耗时操作。
	2）、MainActivity，由于用户只关心最后的显示的这一帧，对我们的布局的层次要求要减少，自定义控件的话测量、布局、绘制的时间。
		不要在onCreate、onStart、onResume当中做耗时操作。
	3）、对于SharedPreference的初始化。
		因为他初始化的时候是需要将数据全部读取出来放到内存当中。
		优化1：可以尽可能减少sp文件数量(IO需要时间)；2.像这样的初始化最好放到线程里面；3.大的数据缓存到数据库里面。

app启动的耗时主要是在：Application初始化 + MainActivity的界面加载绘制时间。

由于MainActivity的业务和布局复杂度非常高，甚至该界面必须要有一些初始化的数据才能显示。
那么这个时候MainActivity就可能半天都出不来，这就给用户感觉app太卡了。

我们要做的就是给用户赶紧利落的体验。点击app就立马弹出我们的界面。
于是乎想到使用SplashActivity--非常简单的一个欢迎页面上面都不干就只显示一个图片。

但是SplashActivity启动之后，还是需要跳到MainActivity。MainActivity还是需要从头开始加载布局和数据。
想到SplashActivity里面可以去做一些MainActivity的数据的预加载。然后需要通过意图传到MainActivity。

可不可以再做一些更好的优化呢？
耗时的问题：Application+Activity的启动及资源加载时间；预加载的数据花的时间。

如果我们能让这两个时间重叠在一个时间段内并发地做这两个事情就省时间了。

解决：
	将SplashActivity和MainActivity合为一个。

	一进来还是现实的MainActivity，SplashActivity可以变成一个SplashFragment，然后放一个FrameLayout作为根布局直接现实SplashFragment界面。
	SplashFragment里面非常之简单，就是现实一个图片，启动非常快。
	当SplashFragment显示完毕后再将它remove。同时在splash的2S的友好时间内进行网络数据缓存。
	这个时候我们才看到MainActivity，就不必再去等待网络数据返回了。

	问题：SplashView和ContentView加载放到一起来做了 ，这可能会影响应用的启动时间。
	解决：可以使用ViewStub延迟加载MainActivity当中的View来达到减轻这个影响。

viewStub的设计就是为了防止MainActivity的启动加载资源太耗时了。延迟进行加载，不影响启动，用户友好。
但是viewStub加载也需要时间。等到主界面出来以后。
viewStub.inflate(xxxx);

5.如何设计延迟加载DelayLoad
	第一时间想到的就是在onCreate里面调用handler.postDelayed()方法。
	问题：这个延迟时间如何控制？
	不同的机器启动速度不一样。这个时间如何控制？
	假设，需要在splash做一个动画--2S

	需要达到的效果：应用已经启动并加载完成，界面已经显示出来了，然后我们再去做其他的事情。

如果我们这样：
		mHandler.postDelayed(new Runnable() {
			@Override
			public void run() {
				mProgressBar.setVisibility(View.GONE);
				iv.setVisibility(View.VISIBLE);
			}
		}, 2500);

是没法做到等应用已经启动并加载完成，界面已经显示出来了，然后我们再去做其他的事情。

问题：什么时候应用已经启动并加载完成，界面已经显示出来了。
onResume执行完了之后才显示完毕。不行。
onwindowfocuschange
ViewTreeObserver


