
性能优化
===================================================
主要是经验---车技。

1.如何去优化自己现有的项目，运行更加流畅。
app进程 16M,32M,64M。 8M

2.以后开发项目的时候就要从一开始就摆好发车车技。

-----------------------内存泄漏----------------------------

C/C++ 自己去分配内存和释放内存--手动管理
malloc  free

什么是内存泄露：内存不在GC掌控之内了。
		当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而就导致
		对象不能被回收。这种导致了本该被回收的对象不能被回收而停留在堆内存中，就产生了内存泄漏

了解java的GC内存回收机制：某对象不再有任何的引用的时候才会进行回收。

ArrayList<String> list = new Arraylist<String>();


了解内存分配的几种策略：
1.静态的
	静态的存储区：内存在程序编译的时候就已经分配好，这块的内存在程序整个运行期间都一直存在。
	它主要存放静态数据、全局的static数据和一些常量。

2.栈式的
	在执行函数(方法)时，函数一些内部变量的存储都可以放在栈上面创建，函数执行结束的时候这些存储单元就会自动被释放掉。
	栈内存包括分配的运算速度很快，因为内置在处理器的里面的。当然容量有限。
3.堆式的
	也叫做动态内存分配。有时候可以用malloc或者new来申请分配一个内存。在C/C++可能需要自己负责释放（java里面直接依赖GC机制）。
	在C/C++这里是可以自己掌控内存的，需要有很高的素养来解决内存的问题。java在这一块貌似程序员没有很好的方法自己去解决垃圾内存，需要的是编程的时候就要注意自己良好的编程习惯。

区别：堆是不连续的内存区域，堆空间比较灵活也特别大。
	栈式一块连续的内存区域，大小是有操作系统觉决定的。

堆管理很麻烦，频繁地new/remove会造成大量的内存碎片，这样就会慢慢导致效率低下。
对于栈的话，他先进后出，进出完全不会产生碎片，运行效率高且稳定。

public class Main{
	int a = 1;
	Student s = new Student();
	public void XXX(){
		int b = 1;//栈里面
		Student s2 = new Student();
	}

}

1.成员变量全部存储在堆中(包括基本数据类型，引用及引用的对象实体)---因为他们属于类，类对象最终还是要被new出来的。
2.局部变量的基本数据类型和引用存储于栈当中，引用的对象实体存储在堆中。-----因为他们属于方法当中的变量，生命周期会随着方法一起结束。

我们所讨论内存泄露，主要讨论堆内存，他存放的就是引用指向的对象实体。

有时候确实会有一种情况：当需要的时候可以访问，当不需要的时候可以被回收也可以被暂时保存以备重复使用。

比如：ListView或者GridView、REcyclerView加载大量数据或者图片的时候，
	图片非常占用内存，一定要管理好内存，不然很容易内存溢出。
	滑出去的图片就回收，节省内存。看ListView的源码----回收对象，还会重用ConvertView。
	如果用户反复滑动或者下面还有同样的图片，就会造成多次重复IO（很耗时），
	那么需要缓存---平衡好内存大小和IO，算法和一些特殊的java类。
	算法：lrucache(最近最少使用先回收)
	特殊的java类：利于回收，StrongReference，SoftReference，WeakReference，PhatomReference

StrongReference强引用：
	回收时机：从不回收 使用：对象的一般保存  生命周期：JVM停止的时候才会终止
SoftReference，软引用
	回收时机：当内存不足的时候；使用：SoftReference<String>结合ReferenceQueue构造有效期短；生命周期：内存不足时终止
WeakReference，弱引用
	回收时机：在垃圾回收的时候；使用：同软引用； 生命周期：GC后终止
PhatomReference 虚引用
	回收时机：在垃圾回收的时候；使用：合ReferenceQueue来跟踪对象呗垃圾回收期回收的活动； 生命周期:GC后终止

开发时，为了防止内存溢出，处理一些比较占用内存大并且生命周期长的对象的时候，可以尽量使用软引用和弱引用。
软引用比LRU算法更加任性，回收量是比较大的，你无法控制回收哪些对象。

比如使用场景：默认头像、默认图标。
ListView或者GridView、REcyclerView要使用内存缓存+外部缓存(SD卡)



---------------内存泄露例子----------------
单例模式导致内存对象无法释放而导致内存泄露

MainActivity在内存当中泄露了。
这个故事告诉我们能用Application的context就用Application的
CommonUtil生命周期跟MainActivity不一致，而是跟Application进程同生同死。

旋转3次：会在内存里面开辟三个MainActivity
实际上3次以上都只会有2个MainActivity。当GC回收的时候会将除了第0个和最后这一个留着其他的都会被回收。

优化两个情况：
	1.主动；平时
	2.被动，很卡的时候  出现问题的时候。

如果我们不知道代码内存泄露的情况，如何判断我们的项目里面有哪些是有内存泄露情况的？

1.凭借工具结合自己的经验来判断。
往往我们的app在某个时候或者某个 操作以后会出现很卡的现象。

1）判断就是查看内存抖动情况

Android Monitor
MAT (对Eclipse插件使用的，也有独立分析工具)

查找引用了该对象的外部对象有哪些，
然后一个一个去猜，查找可能内存泄露的嫌疑犯，依据：看(读代码和猜)他们的生命周期是否一致(可以通过快照对比)，如果生命周期一致了肯定不是元凶。

排除一些容易被回收的(软引用、虚引用、弱引用)


设置监听很容易出现内存泄露
handler.post(callback)
onDestroy(){
	handler.removeCallback();
}

===================第三节课========================

往往做项目的时候情况非常复杂，或者项目做得差不多了想起来要性能优化检查下内存泄露。

如何找到项目中存在的内存泄露的这些地方呢？

1.确定是否存在内存泄露
	1)Android Monitors的内存分析
		最直观的看内存增长情况，知道该动作是否发生内存泄露。
		动作发生之前：GC完后内存1.4M; 动作发生之后：GC完后内存1.6M

	2)使用MAT内存分析工具
	MAT分析heap的总内存占用大小来初步判断是否存在泄露
	Heap视图中有一个Type叫做data object，即数据对象，也就是我们的程序中大量存在的类类型的对象。
	在data object一行中有一列是“Total Size”，其值就是当前进程中所有Java数据对象的内存总量，
	一般情况下，这个值的大小决定了是否会有内存泄漏。
	我们反复执行某一个操作并同时执行GC排除可以回收掉的内存，注意观察data object的Total Size值，
	正常情况下Total Size值都会稳定在一个有限的范围内，也就是说由于程序中的的代码良好，没有造成对象不被垃圾回收的情况。
	反之如果代码中存在没有释放对象引用的情况，随着操作次数的增多Total Size的值会越来越大。
那么这里就已经初步判断这个操作导致了内存泄露的情况。

2.先找怀疑对象(哪些对象属于泄露的)
	MAT对比操作前后的hprof来定位内存泄露是泄露了什么数据对象。（这样做可以排除一些对象，不用后面去查看所有被引用的对象是否是嫌疑）
	快速定位到操作前后所持有的对象哪些是增加了(GC后还是比之前多出来的对象就可能是泄露对象嫌疑犯)
	技巧：Histogram中还可以对对象进行Group，比如选择Group By Package更方便查看自己Package中的对象信息。

3. MAT分析hprof来定位内存泄露的原因所在。(哪个对象持有了上面怀疑出来的发生泄露的对象)
	1）Dump出内存泄露“当时”的内存镜像hprof，分析怀疑泄露的类；
	2）把上面2得出的这些嫌疑犯一个一个排查个遍。步骤：
		(1)进入Histogram，过滤出某一个嫌疑对象类
		(2)然后分析持有此类对象引用的外部对象（在该类上面点击右键List Objects--->with incoming references）
		(3)再过滤掉一些弱引用、软引用、虚引用，因为它们迟早可以被GC干掉不属于内存泄露
		   (在类上面点击右键Merge Shortest Paths to GC Roots--->exclude all phantom/weak/soft etc.references)
		(4)逐个分析每个对象的GC路径是否正常
		   此时就要进入代码分析此时这个对象的引用持有是否合理，这就要考经验和体力了！
		   （比如上课的例子中：旋转屏幕后MainActivity有两个，肯定MainActivity发生泄露了，
		     那谁导致他泄露的呢？原来是我们的CommonUtils类持有了旋转之前的那个MainActivity他，
		     那是否合理？结合逻辑判断当然不合理，由此找到内存泄露根源是CommonUtils类持有了该MainActivity实例造成的。
		     怎么解决？罪魁祸首找到了，怎么解决应该不难了，不同情况解决办法不一样，要靠你的智慧了。）

context.getapplictioncontext()可以吗？
可以！！只要让CommonUtils类不直接只有MainActivity的实例就可以了。

一般我是最笨的方法解决
new出来对象，用完后把它 = null;这样算不算优化
假如：方法里面定义的对象，要去管吗？一般不需要管。
	自己=null，要自己去控制所有对象的生命周期 判断各种空指针，有点麻烦。
	但是在很多时候去想到主动将对象置为null是很好的习惯。


------------------
判断一个应用里面内存泄露避免得很好，怎么看？
当app退出的时候，这个进程里面所有的对象应该就都被回收了，尤其是很容易被泄露的（View，Activity）是否还内存当中。
可以让app退出以后，查看系统该进程里面的所有的View、Activity对象是否为0.
工具：使用AndroidStudio--AndroidMonitor--System Information--Memory Usage查看Objects里面的views和Activity的数量是否为0.
命令行模式：       ？？？？


===========================内存泄露经常出现的例子=============================
内存泄露(Memory Leak)：
	进程中某些对象已经没有使用价值了，但是他们却还可以直接或者间接地被引用到GC Root导致无法回收。
	当内存泄露过多的时候，再加上应用本身占用的内存，日积月累最终就会导致内存溢出OOM.
内存溢出（OOM）：


1.静态变量引起的内存泄露
	当调用getInstance时，如果传入的context是Activity的context。只要这个单利没有被释放，那么这个
	Activity也不会被释放一直到进程退出才会释放。
	public class CommUtil {
	    private static CommUtil instance;
	    private Context context;
	    private CommUtil(Context context){
		this.context = context;
	    }

	    public static CommUtil getInstance(Context mcontext){
		if(instance == null){
		    instance = new CommUtil(mcontext);
		}
	//        else{
	//            instance.setContext(mcontext);
	//        }
		return instance;
	    }

2.非静态内部类引起内存泄露
(包括匿名内部类)
	错误的示范：

	    public void loadData(){//隐士持有MainActivity实例。MainActivity.this.a
		new Thread(new Runnable() {
		    @Override
		    public void run() {
			while(true){
			    try {
				//int b=a;
				Thread.sleep(1000);
			    } catch (InterruptedException e) {
				e.printStackTrace();
			    }
			}
		    }
		}).start();
	    }
	解决方案：
	将非静态内部类修改为静态内部类。
	（静态内部类不会隐士持有外部类）

当使用软引用或者弱引用的时候，MainActivity难道很容易或者可以被GC回收吗？》
GC回收的机制是什么？当MainActivity不被任何的对象引用。
虽然Handler里面用的是软引用/弱引用，但是并不意味着不存在其他的对象引用该MainActivity。
我连MainActivity都被回收了，那他里面的Handler还玩个屁。

3.不需要用的监听未移除会发生内存泄露
	例子1：
//        tv.setOnClickListener();//监听执行完回收对象
        //add监听，放到集合里面
        tv.getViewTreeObserver().addOnWindowFocusChangeListener(new ViewTreeObserver.OnWindowFocusChangeListener() {
            @Override
            public void onWindowFocusChanged(boolean b) {
                //监听view的加载，view加载出来的时候，计算他的宽高等。

                //计算完后，一定要移除这个监听
                tv.getViewTreeObserver().removeOnWindowFocusChangeListener(this);
            }
        });

	例子2：
	        SensorManager sensorManager = getSystemService(SENSOR_SERVICE);
        Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);
        sensorManager.registerListener(this,sensor,SensorManager.SENSOR_DELAY_FASTEST);
        //不需要用的时候记得移除监听
        sensorManager.unregisterListener(listener);


4.资源未关闭引起的内存泄露情况
	比如：BroadCastReceiver、Cursor、Bitmap、IO流、自定义属性attribute
attr.recycle()回收。
当不需要使用的时候，要记得及时释放资源。否则就会内存泄露。

5.无限循环动画
没有在onDestroy中停止动画，否则Activity就会变成泄露对象。
比如：轮播图效果。


====================================性能优化的帮助工具=================
	MAT,
	Memory Monitor(属于AndroidMonitor中一个模块)，
	HeapTool(查看堆信息)，
	Allaction Tracking，
	LeakCanary
	Lint工具

1.Allaction Tracking
追踪内存分配信息。可以很直观地看到某个操作的内存是如何进行一步一步地分配的。


2.LeakCanary
Square公司
可以直接在手机端查看内存泄露的工具
实现原理：本质上还是用命令控制生成hprof文件分析检查内存泄露。
然后发送通知。
Application
	install()
LeakCanary
	androidWatcher()
RefWatcher
	new AndroidWatcherExecutor() --->dumpHeap()/analyze()(--->runAnalysis())--->Hprof文件分析
	new AndroidHeapDumper()
	new ServiceHeapDumpListener


3.Lint分析工具
Android Studio很方便 很好用。
	检测资源文件是否有没有用到的资源。
	检测常见内存泄露
	安全问题SDK版本安全问题
	是否有费的代码没有用到
	代码的规范---甚至驼峰命名法也会检测
	自动生成的罗列出来
	没用的导包
	可能的bug


渲染机制以及优化

一、了解渲染刷新机制
VSYNC(垂直刷新/绘制)

60HZ是屏幕刷新理想的频率。60fps---一秒内绘制的帧数。
24帧/秒 电源胶卷时代

在60fps内，系统会得到发送的VSYNC(垂直刷新)信号qu去进行渲染，就会正常地绘制。
60fps要求：每一帧只能停留16ms.

VSYNC：有两个概念
	1）Refresh Rate：屏幕在一秒时间内刷新屏幕的次数----有硬件的参数决定，比如60HZ.
	2）Frame Rate：GPU在一秒内绘制操作的帧数，比如：60fps。

GPU刷新：GPU帮助我们将UI组件等计算成纹理Texture和三维图形Polygons
	同时会使用OpenGL---会将纹理和Polygons缓存在GPU内存里面。
View Tree。

卡顿是如何造成的
卡主线程了！（卡UI线程）
1.外部引起的
	比如：Activity里面直接进行网络访问/大文件的IO操作
内存这一块有些什么要注意的。

	1）内存抖动的问题。
		new Object

		obj = null
	2)一个方法太耗时了。

2.View本身的卡顿
自定义View要注意的，能否优化、

	1）可以使用Allocation Tracing来定位大致的情况
	2）可以使用TraceView来确定详细的问题所在。

优化：
1.渲染性能的优化
2.防止过度绘制


---------------------------
在我们的绘制渲染机制里面比较耗时的：
1.CPU计算时间
	CPU的优化，从减轻加工View对象成Polygons和Texture来下手
	View Hierarchy中包涵了太多的没有用的view，这些view根本就不会显示在屏幕上面，
	一旦触发测量和布局操作，就会拖累应用的性能表现。

	1.如何找出里面没用的view呢？或者减少不必要的view嵌套。
	工具：Hierarchy Viewer检测

	优化：
		1）当我们的布局是用的FrameLayout的时候，我们可以把它改成merge
			可以避免自己的帧布局和系统的ContentFrameLayout帧布局重叠造成重复计算(measure和layout)
	ViewStub：当加载的时候才会占用。不加载的时候就是隐藏的，仅仅占用位置。

	[hierarchyviewer]Unable to capture data for node
	android.widget.LinearLayout@e6fdb11 in window com.example.android.mobileperf.render/com.example.android.mobileperf.render.ChatumLatinumActivity on device 192.168.56.101:5555

	三个圆点分别代表：测量、布局、绘制三个阶段的性能表现。
	1）绿色：渲染的管道阶段，这个视图的渲染速度快于至少一半的其他的视图。
	2）黄色：渲染速度比较慢的50%。
	3）红色：渲染速度非常慢。

	优化思想:查看自己的布局，层次是否很深以及渲染比较耗时，然后想办法能否减少层级以及优化每一个View的渲染时间。


2.CPU将计算好的Polygons和Texture传递到GPU的时候也需要时间
	OpenGL ES API允许数据上传到GPU后可以对数据进行保存，做了缓存。

3.GPU进行格栅化
	优化：尽量避免过度绘制（overdraw）
	GPU如何优化：
		1.背景经常容易造成过度绘制。
		手机开发者选项里面找到工具：Debug GPU overdraw
		由于我们布局设置了背景，同时用到的MaterialDesign的主题会默认给一个背景。
		/解决的办法：将主题添加的背景去掉

		2.自定义控件如何处理过度绘制。
		可以通过裁剪来处理。

===================================电量优化====================


使用时出现的错误：
1.json: unsupported value: NaN
	有人用了描述：
	the problem started when reset the battery stats and enabled full-wake-history
	解决：重启手机再试就好了。

2.打开生成的HTML显示错误如下：
WARNING: Visualizer disabled. If you see this message, download the HTML then open it.
解决：需要翻墙访问谷歌服务。

3.进部署好的动脑服务器docker，显示错误如下：
{"UploadResponse":[{"sdkVersion":23,"historianV2Cs...

https://github.com/google/battery-historian/issues/64
解决：You need a network connection.需要翻墙。 动脑的centos无法翻墙访问谷歌服务导致。

4.进部署好的动脑服务器docker，没有显示错误，但是最上面提示了红色的颜色块，表示访问出错。
解决：无法翻墙访问谷歌服务导致。

=============================================================

重要的参数：WiFi、wake_lock、conn、mobile_ratio(蜂窝信号)

1.为了省电，有些工作可以放当手机插上电源的时候去做。往往这样的情况非常多。
像这些不需要及时地和用户交互的操作可以放到后面处理。
比如：360手机助手，当充上电的时候，才会自动清理手机垃圾，自动备份上传图片、联系人等到云端。

提问：拍照和图片的处理，他们可以做一些电量的优化吗？
假如现在没有充电，电量比较低，拍照动作是需要立马执行的，
但是图片处理（需要消耗大量的计算---电量的大量消耗）是否可以放在用户手机插上电源之后来处理？

如何立即获取手机当前充电状态，我们可以有针对性地对一些代码做优化。

2.wake_lock
系统为了节省电量，CPU在没有任务忙的时候就会自动进入休眠。
有任务需要唤醒CPU高效执行的时候，就会给CPU加wake_lock锁。

wake_lock锁主要是相对系统的休眠而言的，意思就是我的程序给CPU加了这个锁那系统就不会休眠了，这样做的目的是为了全力配合我们程序的运行。有的情况如果不这么做就会出现一些问题，比如微信等及时通讯的心跳包会在熄屏不久后停止网络访问等问题。所以微信里面是有大量使用到了wake_lock锁。

wake_lock:两种锁，一种计数锁；非计数锁(锁了很多次，只需要release一次就可以解除了)
源码：count++

wake_lock应该是大家开发时经常用的手段吧，所以没有特别细地讲解，如果大家需要的话下节课给大家补充下这块的概念和使用。

大家经常犯的错误，我们很容易去唤醒CPU来干货，但是很容易忘记释放wake_lock.
解决：powerManager的API
记得添加权限：
<uses-permission android:name="android.permission.INTERNET"></uses-permission>
    <uses-permission android:name="android.permission.WAKE_LOCK"></uses-permission>
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"></uses-permission>

  mWakelock.acquire();//唤醒CPU
  mWakelock.release();//记得释放CPU锁

//判断网络连接
   private boolean isNetWorkConnected() {
        ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();
        return (activeNetworkInfo!=null&&activeNetworkInfo.isConnected());
    }


//---------------
如何去改进，对任务调度的优化。
//--------------
网络优化---也解决电量问题。


    public void setRepeating(int type, long triggerAtMillis,
            long intervalMillis, PendingIntent operation) {
        setImpl(type, triggerAtMillis, legacyExactLength(), intervalMillis, 0, operation,
                null, null, null, null, null);
    }

    public void setExact(int type, long triggerAtMillis, PendingIntent operation) {
        setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, 0, operation, null, null, null,
                null, null);
    }

原因：
WINDOW_HEURISTIC:探试的，探索的;（意思：有范围浮动的，时间不确定的）
    private long legacyExactLength() {
        return (mAlwaysExact ? WINDOW_EXACT : WINDOW_HEURISTIC);
    }


锁屏和点亮屏幕的广播。监听。

如果电量采集不到，可能要进入手机的工程模式，打开电量日志采集。


python historian.py -a dongnaobugreport.txt > dongnaobugreport.txt.html


优化四：大量高频次的CPU唤醒及操作，我们最好把这些操作集中处理。
我们可以采取一些算法来解决。
可以借鉴谷歌的精髓，JobScheduler/GCM


python historian.py -a batterystat666s.txt > battery.html

电量优化---网络优化



5.0API以后用的JobScheduler
5.0API之前用GCM---谷歌的Google Play ServiceManager，国内基本是废的。(里面有很多的网络优化的代码--包括访问策略等)


JobInfo
JobScheduler
JobService


进程1
MyService{
	MyBinder extends MyInterface.Stub{
		a(){
		//
		}
	}
}

MyInterface.aidl{
	接口方法a();
}

进程2
MyInterface.aidl{
	接口方法a();
}

bindService(service,new ServiceConnection(){
	onServiceConnected(IBinder binder){
		//建立连接
		MyInterface interface = binder.asInterface();

	}
})

interface.a();


Zygote进程--Linux核心
启动系统进程SystemServer，开启一些列的关键服务：AMS/PMS/WMS/JobSchedulerService


/data/system/job/jobs.xml文件---永久的任务。


网络的优化

1.请求的缓存。
Http请求是可以做缓存的。


三级缓存
内存缓存、外部缓存
算法LruCache
+自定的 一周过期等等。
Sqlite缓存+加密

=============================================
Bitmap的优化

图片压缩

BitmapFactory

BitmapFactory.Options:参数：
inDensity:bitmap的像素密度
inTargetDensity：bitmap最终的像素密度

DensityDpi(屏幕的像素密度)  分辨率		Density
160dpi				320x533		1

px  = dp*Density

 图片存在的几种形式：
	File
	流的形式
	Bitmap的形式---内存


1.质量压缩
AB
CD
压缩后
AA
AA


2.尺寸压缩

3.采样率压缩



=====================终极压缩====================================

1.IOS拍照1M的图片要比安卓拍照排出来的5M的图片还要清晰。
都是在同一个环境下，保存的都是JPEG。

为什么？

2.图像处理引擎
95年 JPEG处理引擎，用于最初的在PC上面处理图片的引擎。

05年  skia开源的引擎, 开发了一套基于JPEG处理引擎的第二次开发。便于浏览器的使用。

07年， 安卓上面用的什么引擎？
skia引擎，阉割版。
--------------------
谷歌拿了skia 思考了半天做了一个决定，去掉一个编码算法---哈夫曼算法。采用定长编码算法。
但是解码还是保留了哈夫曼算法。
-----------------------
导致了图片处理后文件变大了。
理由：当时由于CPU和内存在手机上都非常吃紧 性能差，由于哈夫曼算法非常吃CPU，被迫用了其他的算法。
 ---------------------------------------------------------
|   我们的优化：                                            |
|  绕过安卓Bitmap API层，来自己编码实现----修复使用哈夫曼算法。   |
 ----------------------------------------------------------

argb
一个像素点包涵四个信息：alpha，red,green，blue

a b c d e

abcde acdbe bacde ⋯⋯

101010100011100
a:001
b:010
c:011
d:100
e:101
用3位来表示一个字符信息，属于定长编码的最优。

abcde
001 010 011 100 101
加权信息编码

a:80%
b:10%
c:10%
d:0%
e:0%
这种情况，编码就可以优化了
a:01
b:10
c:11
优化后的abc:01 10 11
优化前的abc:001 010 011

问题来了：
	如何得到每一个字母出现的权重？
哈夫曼编码：需要去扫描真个信息(图片信息--每一个像素包括ARGB)，药大量计算，很吃CPU。

1280*800像素*4

-------------------如何实现----------=-----------

下载JPEG引擎使用的库---libjpeg库
http://www.ijg.org/

基于该引擎来做一定的开发----自己实现编码。

1.导入库文件libjpegbither.so
2.导入头文件
3.写mk文件
Android.mk
Applicatoin.mk

4.写代码
C++: XX.cpp
C:   XX.c


1.将android的bitmap解码，并转换成RGB数据
一个图片信息---像素点(argb)
alpha去掉


2.JPEG对象分配空间以及初始化
3.指定压缩数据源
4.获取文件信息
5.为压缩设置参数，比如图像大小、类型、颜色空间
  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
6.开始压缩
jpeg_start_compress()
7.压缩结束
jpeg_finish_compress()
8.释放资源

===============================数据传输效率优化====================

一、数据的序列化和反序列化
服务器对象Object----流--->客户端Object对象

序列化：
Serializable/Parcelable

时间：1ms * 10 * 50 * 20 = 10000ms
性能：内存的浪费和CPU计算时间的占用。

json/xml
json序列化的工具GSON/fastjson

FlatBuffer:基于二进制的文件。
json：基于字符串的

Gson.from("")
Gson.toString(object)

PeopleList{
	List<People> peoples;

}

============================多线程===========================
生产者消费者线程模式

25fps
60fps

MessageQueue 库存

AsyncTask 异步任务

Callable
Future

异步任务执行的结果，主线程无法轻易的获取

Java FutureTask 异步任务操作提供了便利性
1.获取异步任务的返回值
2.监听异步任务的执行完毕
3.取消异步任务

doBackground(call)
call的返回值在Future的done方法中获取

->onPostExecute

new MyTask().execute();

实例化：
new AsyncTask() -> new FutureTask()

执行：
Executor.execute(mFuture) -> SerialExecutor.myTasks（队列）
-> (线程池)THREAD_POOL_EXECUTOR.execute

线程池中的所有线程，为了执行异步任务

CORE_POOL_SIZE 核心线程数
MAXIMUM_POOL_SIZE 最大线程数量
KEEP_ALIVE 1s闲置回收
TimeUnit.SECONDS 时间单位
sPoolWorkQueue 异步任务队列
sThreadFactory 线程工厂

如果当前线程池中的数量小于corePoolSize，创建并添加的任务。
如果当前线程池中的数量等于corePoolSize，缓冲队列 workQueue未满，那么任务被放入缓冲队列、等待任务调度执行。
如果当前线程池中的数量大于corePoolSize，缓冲队列workQueue已满，并且线程池中的数量小于maximumPoolSize，新提交任务会创建新线程执行任务。
如果当前线程池中的数量大于corePoolSize，缓冲队列workQueue已满，并且线程池中的数量等于maximumPoolSize，新提交任务由Handler处理。
当线程池中的线程大于corePoolSize时，多余线程空闲时间超过keepAliveTime时，会关闭这部分线程。

public static final Executor THREAD_POOL_EXECUTOR
= new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,
		TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);

1.线程池容量不够抛出异常
2.内存泄露
3.一个线程，一个异步任务（？）

